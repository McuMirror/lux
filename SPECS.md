Lux Specification
=================

Lux refers to a protocol stack which is designed to control many lightweight nodes. 

It supports the transmission of power and data from a host device to one or more nodes over a simple serial link. This mode is capable of data rates approaching 3 megabits per second and supplying 30 Watts of power over distances of up to 100 feet. It is designed to be easy to implement and uses low-cost cabling and connectors.

Additionally, it also supports transmitting data over UDP (e.g. with IP & Ethernet). This mode makes it easy to abstract the controller from the physical hardware.

### Stack Comparison

The *Serial/Hardware* stack is:

1. Serial Physical Layer (48V; RS-485; 3Mbps)
2. Data Link Layer (COBS; CRC)
3. MAC Layer (Speak-when-spoken-to)
4. Application Layer

The *Network/IP* stack is:

1. Physical Layer (Unspecified; e.g. Ethernet)
2. Data Link Layer (Unspecified; e.g. IPv4)
3. Transport Layer (UDP)
3. Data Link Layer (COBS; CRC)
3. MAC Layer (Speak-when-spoken-to)
4. Application Layer

Serial Physical Layer
---------------------

Lux is designed with a hub-and-spoke model in mind. Each lux universe must have exactly one master but may have an arbitrary number of nodes (limited only by the bandwidth of the bus.)

The master exposes one or more RJ-11 jacks (6p4c) and each node exposes one RJ-11 jack. Devices are connected with straight-through RJ-11 cables no longer than 100 feet and no thinner than 26 AWG per conductor.

The lux pinout is as follows:
 1. GND
 2. A
 3. B
 4. PWR

The voltage that nodes see between PWR and GND is nominally 48 volts, but may be as high as 54 volts or as low as 42 volts. The master or hub provides this power, and nodes consume it. The master should not output less than 48 volts or more than 54 volts. The drop in the cabling may be as large as 6 volts.

Nodes may be bus-powered or self-powered. A bus-powered node must not draw more than 650 mA from the bus. A self-powered node must use GND as reference for the data signals (i.e. must not be floating or at a different potential from the bus.)

RS-485 is used for the data lines. Nodes and masters should implement the recommended bias resistors and a termination resistor of 120 ohms, as well as a RS-485 compatible tranceiver capable of 3 megabit per second communcation. The serial protocol uses 3 megabaud, 8 data bits, 1 start bit, 1 stop bit, and no parity. The serial link is half-duplex.

Network Transport Layer
-----------------------

Lux uses UDP for sending data over the Internet/LAN. Lux does not specify which protocols must be used below UDP, but usualy it is IPv4 or IPv6.

Common Layers
-------------
### Data Link Layer
Lux packets are encoded using consistent-overhead byte stuffing (COBS). A NULL (out-of-band 0 byte) is placed at the end of a packet. 

Multi-byte values are transmitted in little-endian format (*not* "network"/big-endian!)

A packet consists of five parts:

<table><tr>
 <td>Destination Address <br> (4&nbsp;bytes)</td>
 <td>Command <br> (1&nbsp;byte)</td>
 <td>Index <br> (1&nbsp;byte)</td>
 <td width="100%">Payload <br> (0-1024&nbsp;bytes) </td>
 <td>CRC <br> (4&nbsp;bytes) </td>
</tr></table>

The destination address is four bytes. Nodes may have one or more addresses. One address may be used by multiple nodes (useful for multicast.) Because lux uses hubs, all traffic generated by the host will reach every node. Nodes should filter packets based on the address, and discard any packets not addressed to them. For the rest of this document, the address is assumed to be little-endian.

The *command* and *index* fields are one byte each. They are used by the application layer.

The payload can be between 0 and 1024 bytes long, inclusive (after COBS decoding.) The data contained in the payload is not specified by lux, except by way of the defacto standards described below. Packets with payloads longer than 1024 bytes should be discarded as corrupt.

After the payload comes a 32-bit CRC of the entire packet (after COBS decoding.) If the CRC does not check out, the packet should be discarded as corrupt.

Payload length is never explicitly stated. Instead, packets are null-teriminated. Payload length is defined as the packet length minus 8 bytes, to account for the address and checksum.

Packets shorter than 8 bytes should be discarded, though not necessarily marked as corrupt. An optional feature of this protocol is to start (as well as end) packets with a null. When this happens, the decoder may interpret the data between packets as packets. On an ideal busimplementing this two-zero variant, these packets are of length 0 and do not indicate an error condition.

### MAC Layer

Lux uses a speak-when-spoken-to access control scheme. The master sends packets out to the nodes, and may optionally expect a response. If the master expects a response and does not receive one, it may re-send the packet after a timeout mutually agreed upon in advance by the node and the master. Nodes can only send data back to the master. Node should never spuriously send packets, as they may collide with packets originating from the master.

Due to the topology of the bus, packets originating from nodes will not necessarily reach other nodes. Nodes that are sending packets to the master should clear the destination field (set it to all zeros.) Nodes should never react to packets with this address.

### Application Layer

Each packet sent to a node is a *command*. Commands should be as idempotent/stateless as possible.

The command byte (octet 5) indicates the command type. `0x00` through `0x1F` are reserved for commands common to all lux devices, `0x20` through `0xFF` are device-specific. Example commands inclue ``GET_ID``, ``RESET``, ``GET_ADDR``, ``SET_ADDR``, ``GET_PKTCNT``, ``RESET_PKTCNT``, etc. 

<!-- Some command IDs are common to all lux nodes, others are specific to particular node types. For example, ``FRAME`` is specific to LED strips. -->



#### Responses

In keeping with the MAC, nodes can only transmit responses -- they cannot "push" data. Some commands are *send-recieve*, and are defined to require a response. Others like ``RESET`` are *send-only* do not have a response. It is a violiation of the MAC to respond to send-only command, or to respond with zero or multiple packets to a send-recieve command.

In a response, the destination is set to `0x00000000`, and the `command` and `index` fields are copied from the request packet.

A commmon response is a simple *ACK* containing no other data. In this case, the first byte of the payload is set to `0x00`, followed by the CRC from the request packet. Alternatively, in the case of an error (*NAK*), the response consists of a non-zero error code, followed by the CRC of the request packet (as in an *ACK*).

#### Command Descriptions

Name            | Resp.     | Payload           | Description 
----------------|-----------|-------------------|-------------
`RESET`         | None      | `flags`, 1 byte   | Reboot/reset the node. `flags` are implementation-specific.
`GET_ID`        | Data      | None              | Respond with string containing node name. Identifies implementation running on node.
`GET_DESCRIPTOR`| Data      | None              | Respond with JSON blob describing node.
`GET_ADDR`      | Data      | None              | 72 byte address struct, each `u32`: `{mcast_addr, mcast_mask, unicast_addrs[16]}`
`SET_ADDR`      | Ack       | `addrs`, 72 bytes | Respond with address list, see `GET_ADDR`
`WRITE_CONFIG`  | Ack       | None              | Flush configuration changes to nonvolatile storage
`GET_PKTCNT`    | Data      | None              | Respond with 20 byte counter struct, each `u32`: `{good, malformed, overrun, bad_crc, rx_interrupted}`
`RESET_PKTCNT`  | Ack       | None              | Reset all packet counters to 0

#### `index`

In some cases, it is desirable for a command to transmit more than 1024 bytes. The `index` parameter allows bulk transfers (up to 256kB) by selecting a slice of a request/response.

If a command requires multiple packets, it is important to note that there is no "transaction" -- the node is not required to maintain state. As a result a node does not need to keep track of which segements it has sent or received.

De-facto standards
------------------

The following are not mandatory for implementing a correctly-functioning lux node. However, they are highly recommended to maintain compatibility between nodes.

Nodes should always accept packets on address 0xFFFFFFFF. That way, a node with an unknown or corrupt address filter can always be reached.

Uninitialized nodes should assume address 0x80000000. That way, the master can "enumerate" new nodes by continuously sending zero-length packets to 0x80000000. When an unitialized node is found, it should be configured with a permanent address and stop listening on 0x80000000.

Lux Devices
===========

LED Strip
---------

### Description

A collection of up to 65535 RGB pixels. Each pixel can be controlled independently, with 24 bits of color depth.

### Command Descriptions

In addition to the generic lux commands:

Name            | Resp.     | Payload               | Description 
----------------|-----------|-----------------------|-------------
`FRAME`         | None      | `frame`, *3n* bytes   | Display the payload
`FRAME_ACK`     | Ack       | `frame`, *3n* bytes   | See `FRAME`, but ack
`FRAME_HOLD`    | None      | `frame`, *3n* bytes   | Buffer the payload as a frame, but don't display it
`FRAME_HOLD_ACK`| Ack       | `frame`, *3n* bytes   | See `FRAME_HOLD`, but ack
`SYNC`          | None      | None                  | Display the buffered frame from `FRAME_HOLD` or `FRAME_HOLD_ACK`
`SYNC_ACK`      | Ack       | None                  | See `SYNC`, but ack
`SET_LED`       | Ack       | None                  | Turn the on-board LED on or off
`GET_BUTTON_CNT`| Data      | None                  | Respond with number of times the button has been pressed
`SET_LENGTH`    | Ack       | None                  | Set the number of pixels
`GET_LENGTH`    | Data      | None                  | (*To be deprecated*) Respond with number of pixels

`frame` buffers must be exactly *3n* bytes long, where *n* is the length of the strip as discovered by `GET_DESCRIPTOR` or `GET_LENGTH`.
The three consecutive bytes represent `R`, `G`, and `B` components respectively. 

LED Spot
--------

### Description

A single RGB pixel with 24 bits of color depth

### Command Descriptions

In addition to the generic lux commands:

Name            | Resp.     | Payload               | Description 
----------------|-----------|-----------------------|-------------
`FRAME`         | None      | `frame`, 3 bytes      | Display the payload
`FRAME_ACK`     | Ack       | `frame`, 3 bytes      | See `FRAME`, but ack
`FRAME_HOLD`    | None      | `frame`, 3 bytes      | Buffer the payload, but don't display it
`FRAME_HOLD_ACK`| Ack       | `frame`, 3 bytes      | See `FRAME_HOLD`, but ack
`SYNC`          | None      | None                  | Display the buffered color from `FRAME_HOLD` or `FRAME_HOLD_ACK`
`SYNC_ACK`      | Ack       | None                  | See `SYNC`, but ack
`SET_LED`       | Ack       | None                  | Turn the on-board LED on or off

Bootloader
----------

### Description

A bootloader implementation for re-flashing devices in the field.

### Command Descriptions

In addition to the generic lux commands:

Name            | Resp.     | Payload               | Description 
----------------|-----------|-----------------------|-------------
`INVALIDATE_APP`| Ack       | None                  | Prevent the existing application from booting
`FLASH_ERASE`   | Ack       | `u32 addr` page       | Erase a FLASH page at base address `addr`
`FLASH_WRITE`   | Data      | `u32 addr, data[]`    | Write `data` to FLASH at address `addr`. Respond with data written.
`FLASH_READ`    | Data      | `u32 addr, u16 len`   | Read back `len` bytes of data from `addr`

It is important to call `INVALIDATE_APP` before writing to FLASH.
This "atomically" re-writes the ISR page to point to the bootlodaer, which causes subsequent reboots to jump to the bootloader instead of the application until the flashing is done.

The flashing process should go as follows: 

```
    > INVALIDATE_APP
    < Ack
    > FLASH_ERASE 0x800
    < Ack
    > FLASH_WRITE 0x800 deadbeef...
    < deadbeef...
    > FLASH_WRITE 0x900 deadbeef...
    < deadbeef...
    > FLASH_ERASE 0x400
    < Ack
    ...
    > FLASH_WRITE 0x000 deadbeef...
    < deadbeef...
    > RESET
```
